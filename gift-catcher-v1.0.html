<!DOCTYPE html>
<html lang="zh-TW">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!-- Title is now set from gameConfig in the script -->
        <title>Gift Catcher</title>

        <!-- Load a festive Christmas font -->
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Mountains+of+Christmas:wght@400;700&display=swap"
            rel="stylesheet"
        />

        <!-- Add Tone.js library for sound effects -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>

        <style>
            /* Basic reset and page setup */
            body,
            html {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                overflow: hidden; /* Prevent scrolling */
                font-family: 'Mountains of Christmas', cursive;
                background: transparent; /* Transparent background */
                color: white;
            }

            /* The game canvas will be positioned by JavaScript */
            #gameCanvas {
                display: block;
                background: transparent; /* Transparent canvas */
                position: fixed;
                top: 0;
                left: 0;
                z-index: -1;
            }

            /* Styles for the pop-up screens (start, game over, victory) */
            .overlay {
                width: 100%;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                text-align: center;
                padding: 20px;
                box-sizing: border-box;
                /* Start hidden */
                display: none;
                height: 100%;
            }

            .overlay h1 {
                font-size: 3.5rem;
                margin: 0;
            }

            .overlay h2 {
                font-size: 2rem;
                margin: 10px 0 20px;
            }

            .overlay p {
                font-size: 1.2rem;
                max-width: 400px;
            }

            /* Festive button style */
            .game-button {
                font-family: 'Mountains of Christmas', cursive;
                font-size: 1.25rem;
                font-weight: 700;
                padding: 14px 28px;
                border: none;
                border-radius: 1rem;
                color: white;
                cursor: pointer;
                transition: background-color 0.2s ease; /* Updated transition */
            }

            .game-button:hover {
                background: #e63946; /* Keep hover color change */
                /* transform: translateY(-2px); */ /* Removed transform for flat style */
                /* box-shadow: 0 8px #a4001c; */ /* Removed shadow for flat style */
            }

            .game-button:active {
                /* transform: translateY(4px); */ /* Removed transform for flat style */
                /* box-shadow: 0 2px #a4001c; */ /* Removed shadow for flat style */
                background: #a4001c; /* Added active state color */
            }

            /* New style for button container */
            .button-container {
                display: flex;
                gap: 20px; /* Space between buttons */
                flex-wrap: wrap; /* Allow buttons to wrap on small screens */
                justify-content: center;
            }

            /* Style for the loading message */
            #loadingMessage {
                font-size: 1.5rem;
            }
        </style>
    </head>
    <body>
        <!-- The canvas element where the game is drawn -->
        <canvas id="gameCanvas"></canvas>

        <!-- Start Screen -->
        <div id="startScreen" class="overlay" style="display: flex;">
            <h1
                id="startTitle"
                style="color: #fff; text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;"
            >
                ðŸŽ„ Gift Catcher ðŸŽ„
            </h1>
            <p id="startSubtitle">
                Move your mouse or finger to catch the falling Christmas items in your cart.
                <br />Collect items for a high score! Catching the Grinch costs you one life. If you
                run out of lives, it's game over.
            </p>
            <p id="loadingMessage">Loading holiday cheer...</p>
            <button id="startButton" class="game-button" style="display: none;">
                Start Game
            </button>
        </div>

        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="overlay">
            <h1 id="gameOverTitle">Game Over!</h1>
            <h2 id="finalScoreGO">Your Score: 0</h2>
            <p id="gameOverSubtitle">Better luck next time! ðŸŽ…</p>
            <div class="button-container">
                <!-- Added wrapper for buttons -->
                <button id="restartButtonGO" class="game-button">Play Again</button>
                <button id="logScoreButton" class="game-button">Log Score</button>
                <!-- New Button -->
            </div>
        </div>

        <!-- Victory Screen (Hidden, but kept for DOM structure) -->
        <div id="victoryScreen" class="overlay">
            <h1 id="victoryTitle">Game Over! ðŸŒŸ</h1>
            <h2 id="victorySubtitle">Maximum Score Achieved!</h2>
            <p id="victoryMessage">You're a Christmas champion! Well done!</p>
            <div class="button-container">
                <!-- Added wrapper for buttons -->
                <button id="restartButtonWin" class="game-button">Play Again</button>
                <button id="logScoreButtonWin" class="game-button">Log Score</button>
                <!-- New Button for Win Screen -->
            </div>
        </div>

        <script>
            /*
             * ========================================
             * A. éŠæˆ²æ ¸å¿ƒèˆ‡çŽ©æ³•è¦æ±‚
             * ========================================
             *
             * æ ¸å¿ƒæ¦‚å¿µï¼š
             * è–èª•ç¦®ç‰©æŽ¥çƒéŠæˆ²ï¼ŒçŽ©å®¶éœ€è¦ç”¨è³¼ç‰©è»ŠæŽ¥ä½å¾žå¤©è€Œé™çš„è–èª•ç‰©å“
             *
             * æ ¸å¿ƒçŽ©æ³•ï¼š
             * - æ¡Œé¢ï¼šç§»å‹•æ»‘é¼ æŽ§åˆ¶è³¼ç‰©è»Šå·¦å³ç§»å‹•
             * - è¡Œå‹•è£ç½®ï¼šæ‰‹æŒ‡è§¸æŽ§æ»‘å‹•æŽ§åˆ¶è³¼ç‰©è»Š
             *
             * éŠæˆ²è¦å‰‡ï¼š
             * 1. å„ç¨®è–èª•ç‰©å“ï¼ˆéˆ´éºã€è–‘é¤…äººã€èŠ±åœˆã€é¦´é¹¿, **æ–°ç‰©å“**, **æ ¼æž—å¥‡**ï¼‰æœƒå¾žèž¢å¹•ä¸Šæ–¹éš¨æ©ŸæŽ‰è½
             * 2. ç”¨è³¼ç‰©è»ŠæŽ¥ä½æŽ‰è½çš„ç‰©å“å¯å¾—åˆ†
             * 3. ç‰©å“æŽ‰åˆ°èž¢å¹•åº•éƒ¨æœªæŽ¥ä½ä¸æœƒå¤±åŽ»ç”Ÿå‘½å€¼ã€‚
             * 4. æŽ¥ä½æ ¼æž—å¥‡å°‡å¤±åŽ»ä¸€æ¢ç”Ÿå‘½ã€‚
             * 5. **NEW RULE: The Grinch spawn rate increases every 20 points!**
             * 6. **SOUND RULE: Only play sound on Catch Good Item, Catch Grinch, Start, and Game Over. No sound on missed item.**
             *
             * å¾—åˆ†æ–¹å¼ï¼š
             * - æ¯æŽ¥ä½ä¸€å€‹ç‰©å“å¾— 1 åˆ†
             *
             * éŠæˆ²æˆåŠŸå®šç¾©ï¼š
             * ç„¡ï¼ˆéŠæˆ²ç‚ºé«˜åˆ†æŒ‘æˆ°æ¨¡å¼ï¼Œåªæœ‰å¤±æ•—ï¼‰
             *
             * éŠæˆ²å¤±æ•—å®šç¾©ï¼š
             * ç”Ÿå‘½å€¼æ­¸é›¶ï¼ˆä¸‰æ¬¡æŽ¥ä½æ ¼æž—å¥‡ï¼‰
             *
             * è¦–è¦ºé¢¨æ ¼ï¼š
             * - è–èª•ç¯€ä¸»é¡Œé…è‰²ï¼ˆæ·±è—ç´«æ¼¸å±¤èƒŒæ™¯ã€ç´…è‰²æŒ‰éˆ•ï¼‰
             * - ä¸‹é›ªå‹•ç•«æ•ˆæžœ
             * - ä½¿ç”¨ "Mountains of Christmas" ç¯€æ…¶å­—é«”
             * - ä½¿ç”¨ PNG åœ–ç‰‡ä½œç‚ºéŠæˆ²ç‰©ä»¶
             *
             * ========================================
             */

            // ========================================
            // C. å®¢è£½åŒ–çµæ§‹è¦æ±‚ (Config Mandate) - v2.0 è¦ç¯„
            // ========================================
            // All customizable parameters are in this object
            const gameConfig = {
                /**
                 * 1. TEXT - æ‰€æœ‰ä½¿ç”¨è€…å¯è¦‹çš„æ–‡å­—å…§å®¹
                 */
                text: {
                    documentTitle: 'Gift Catcher',
                    loading: 'æ­£åœ¨è¼‰å…¥ç¯€æ…¶æ°£æ°›...',
                    loadingComplete: percentage => `è¼‰å…¥ä¸­... ${percentage}%`,
                    startTitle: 'ðŸŽ„ Christmas Catcher ðŸŽ„',
                    startSubtitle:
                        'ç§»å‹•æ»‘é¼ æˆ–æ‰‹æŒ‡ä¾†æŽ¥ä½æŽ‰è½çš„è–èª•ç‰©å“ã€‚æ”¶é›†ç‰©å“ç²å¾—é«˜åˆ†ï¼æŽ¥åˆ°æ ¼æž—å¥‡æœƒå¤±åŽ»ä¸€æ¢ç”Ÿå‘½ã€‚å¦‚æžœç”Ÿå‘½ç”¨å®Œå°±éŠæˆ²çµæŸã€‚',
                    startButton: 'é–‹å§‹éŠæˆ²',
                    challengeSuccessTitle: 'æŒ‘æˆ°æˆåŠŸ',
                    challengeSuccessSubtitle: 'åšå¾—å¥½ï¼ä½ å¯ä»¥ç™»éŒ„åˆ†æ•¸ï¼ðŸŽ…',
                    finalScorePrefix: 'ä½ çš„åˆ†æ•¸ï¼š',
                    restartButton: 'å†çŽ©ä¸€æ¬¡',
                    logScoreButton: 'è¨˜éŒ„åˆ†æ•¸',
                    scoreLogged: 'åˆ†æ•¸å·²è¨˜éŒ„',
                    challengeFailedTitle: 'æŒ‘æˆ°å¤±æ•—',
                    challengeFailedMessage: 'éœ€è¦ç²å¾—è‡³å°‘ {minScore} åˆ†æ‰èƒ½ç™»éŒ„åˆ†æ•¸ã€‚',
                    scorePrefix: 'åˆ†æ•¸ï¼š',
                    // Floating message text
                    catchHappy: '+1',
                    catchOuch: '-1'
                },

                /**
                 * 2. STYLES - æ¨£å¼è¨­å®šï¼ˆä½¿ç”¨åµŒå¥—çµæ§‹ï¼‰- v2.0 è¦ç¯„
                 */
                styles: {
                    final: {
                        scoreColor: '#ffffff'
                    },
                    challengeSuccess: {
                        titleColor: '#FFC800',
                        subtitleColor: '#ffffff'
                    },
                    challengeFailed: {
                        titleColor: '#ff0000',
                        subtitleColor: '#ffffff'
                    },
                    // åˆ†æ•¸ç³»çµ±
                    score: {
                        color: '#FFC800'
                    },
                    // å­—é«”é…ç½®
                    fonts: {
                        family: 'Mountains of Christmas, cursive',
                        sizes: {
                            score: '36px'
                        }
                    },
                    // æŒ‰éˆ•é…ç½®
                    buttons: {
                        primaryColor: '#FF3000',
                        primaryTextColor: '#ffffff',
                        secondaryColor: '#00AEFF',
                        secondaryTextColor: '#ffffff'
                    },
                    // é®ç½©å±¤é…ç½®
                    overlay: {
                        backgroundColor: 'rgba(17, 24, 39, 0.8)'
                    },
                    // æµ®å‹•æ–‡å­—é…ç½®
                    floatingText: {
                        font: '700 20px "Mountains of Christmas", cursive',
                        happyColor: '#00cc66',
                        ouchColor: '#ff0000',
                        duration: 500
                    }
                },

                /**
                 * 3. VISUALS - åœ–ç‰‡/åœ–ç¤ºè¨­å®šï¼ˆä¸åŒ…å«èƒŒæ™¯åœ–ç‰‡ï¼‰
                 */
                visuals: {
                    cartSrc:
                        'https://assets.fevercdn.com/promotion/development/AI-Code/img/giftcatcher/Selt.png',
                    // A. Good Items (Score Points)
                    goodItemSources: [
                        'https://assets.fevercdn.com/promotion/development/AI-Code/img/giftcatcher/Gift1.png',
                        'https://assets.fevercdn.com/promotion/development/AI-Code/img/giftcatcher/Gift2.png',
                        'https://assets.fevercdn.com/promotion/development/AI-Code/img/giftcatcher/Gift3.png',
                        'https://assets.fevercdn.com/promotion/development/AI-Code/img/giftcatcher/Gift4.png',
                        'https://assets.fevercdn.com/promotion/development/AI-Code/img/giftcatcher/Gift5.png',
                        'https://assets.fevercdn.com/promotion/development/AI-Code/img/giftcatcher/Gift6.png',
                        'https://assets.fevercdn.com/promotion/development/AI-Code/img/giftcatcher/Gift7.png'
                    ],
                    // B. Bad Items (Lose Life)
                    badItemSources: [
                        'https://assets.fevercdn.com/promotion/development/AI-Code/img/giftcatcher/Grinch.png'
                    ],
                    livesImgSrc:
                        'https://assets.fevercdn.com/promotion/development/AI-Code/img/lives.png',
                    placeholderUrl: (width, height, text) =>
                        `https://placehold.co/${width}x${height}/cc0000/FFF?text=${text}`
                },

                /**
                 * 4. GAMEPLAY - éŠæˆ²é‚è¼¯åƒæ•¸ï¼ˆä½¿ç”¨åµŒå¥—çµæ§‹ï¼‰- v2.0 è¦ç¯„
                 */
                gameplay: {
                    // éŸ³æ•ˆé–‹é—œ
                    soundEnabled: true,
                    // é›£åº¦ç³»çµ±
                    difficulty: {
                        itemSpawnChance: 0.05,
                        difficultyScoreInterval: 20,
                        badItemChanceIncrement: 0.1,
                        maxBadItemChance: 0.5,
                        minItemSpeed: 2,
                        maxItemSpeed: 6
                    },

                    // ä½ˆå±€è¨­å®š
                    layout: {
                        cartWidth: 100,
                        cartHeight: 100,
                        cartHitbox: {
                            width: 80,
                            height: 50,
                            offsetY: 20
                        },
                        minItemSize: 40,
                        maxItemSize: 60,
                        cartBottomOffset: 110
                    },

                    // åˆ†æ•¸ç™»éŒ„é–€æª»
                    minimumScoreToLog: 20
                },

                /**
                 * 5. UI - UIçµ„ä»¶é…ç½® - v2.0 è¦ç¯„ï¼ˆæ–°å¢žå¿…é ˆå±¬æ€§ï¼‰
                 */
                ui: {
                    // ç”Ÿå‘½å€¼ç³»çµ±
                    lives: {
                        initialLives: 3,
                        iconSize: 40,
                        color: '#ff4d4d'
                    },
                    // åˆ†æ•¸ç³»çµ±
                    score: {
                        fontSize: '36px',
                        fontWeight: '700',
                        xOffset: 20,
                        yOffset: 50
                    }
                },

                /**
                 * 6. ANIMATIONS - å‹•ç•«æ•ˆæžœè¨­å®š - v2.0 è¦ç¯„ï¼ˆæ–°å¢žå¿…é ˆå±¬æ€§ï¼‰
                 */
                animations: {
                    // æ‰£è¡€ç´…é–ƒæ•ˆæžœ
                    hitEffect: {
                        duration: 250,
                        color: '#ff0000'
                    }
                },

                /**
                 * 7. AUDIO - éŸ³æ•ˆè¨­å®šï¼ˆé¸å¡«ï¼‰
                 * æ··åˆæ¨¡å¼ï¼šé è¨­ä½¿ç”¨ Tone.jsï¼Œä¸Šå‚³éŸ³æª”å¾Œä½¿ç”¨éŸ³æª”
                 */
                audio: {
                    start: {
                        note: 'C4',
                        duration: '8n',
                        type: 'triangle',
                        url: '',
                        volume: 0.5
                    },
                    catchItem: {
                        note: 'E5',
                        duration: '16n',
                        type: 'sine',
                        url: '',
                        volume: 0.5
                    },
                    catchGrinch: {
                        note: 'A1',
                        duration: '0.5',
                        type: 'sawtooth',
                        url: '',
                        volume: 0.5
                    },
                    gameOver: {
                        note: 'G2',
                        duration: '4n',
                        type: 'sawtooth',
                        url: '',
                        volume: 0.5
                    }
                },

                /**
                 * 8. SETTINGS - åŠŸèƒ½è¨­å®šï¼ˆé¸å¡«ï¼‰
                 */
                settings: {
                    useCustomAudio: false
                }
            };

            // ========================================
            // gameConfigMeta: Metadata Schema - v2.0 è¦ç¯„
            // ========================================
            const gameConfigMeta = {
                text: {
                    startTitle: {
                        label: 'é–‹å§‹ç•«é¢æ¨™é¡Œ',
                        type: 'string',
                        maxLength: 40,
                        category: 'é–‹å§‹ç•«é¢'
                    },
                    startSubtitle: {
                        label: 'é–‹å§‹ç•«é¢èªªæ˜Žæ–‡å­—',
                        type: 'string',
                        maxLength: 200,
                        category: 'é–‹å§‹ç•«é¢'
                    },
                    startButton: {
                        label: 'é–‹å§‹æŒ‰éˆ•æ–‡å­—',
                        type: 'string',
                        maxLength: 20,
                        category: 'é–‹å§‹ç•«é¢'
                    },
                    challengeSuccessTitle: {
                        label: 'æŒ‘æˆ°æˆåŠŸæ¨™é¡Œ',
                        type: 'string',
                        maxLength: 40,
                        category: 'æŒ‘æˆ°æˆåŠŸç•«é¢'
                    },
                    challengeSuccessSubtitle: {
                        label: 'æŒ‘æˆ°æˆåŠŸå‰¯æ¨™é¡Œ',
                        type: 'string',
                        maxLength: 100,
                        category: 'æŒ‘æˆ°æˆåŠŸç•«é¢'
                    },
                    finalScorePrefix: {
                        label: 'åˆ†æ•¸æ¨™ç±¤',
                        type: 'string',
                        maxLength: 20,
                        category: 'éŠæˆ²å®Œæˆç•«é¢'
                    },
                    restartButton: {
                        label: 'é‡æ–°é–‹å§‹æŒ‰éˆ•æ–‡å­—',
                        type: 'string',
                        maxLength: 20,
                        category: 'æŒ‰éˆ•æ–‡å­—'
                    },
                    logScoreButton: {
                        label: 'è¨˜éŒ„åˆ†æ•¸æŒ‰éˆ•æ–‡å­—',
                        type: 'string',
                        maxLength: 20,
                        category: 'æŒ‰éˆ•æ–‡å­—'
                    },
                    scoreLogged: {
                        label: 'åˆ†æ•¸å·²è¨˜éŒ„è¨Šæ¯',
                        type: 'string',
                        maxLength: 30,
                        category: 'æŒ‰éˆ•æ–‡å­—'
                    },
                    challengeFailedTitle: {
                        label: 'æŒ‘æˆ°å¤±æ•—æ¨™é¡Œ',
                        type: 'string',
                        maxLength: 40,
                        category: 'æŒ‘æˆ°å¤±æ•—ç•«é¢'
                    },
                    challengeFailedMessage: {
                        label: 'æŒ‘æˆ°å¤±æ•—è¨Šæ¯',
                        type: 'string',
                        maxLength: 100,
                        category: 'æŒ‘æˆ°å¤±æ•—ç•«é¢'
                    },
                    scorePrefix: {
                        label: 'åˆ†æ•¸å‰ç¶´æ–‡å­—',
                        type: 'string',
                        maxLength: 20,
                        category: 'éŠæˆ²å…§ UI'
                    },
                    catchHappy: {
                        label: 'æŽ¥åˆ°ç¦®ç‰©è¨Šæ¯',
                        type: 'string',
                        maxLength: 20,
                        category: 'éŠæˆ²å…§ UI'
                    },
                    catchOuch: {
                        label: 'æŽ¥åˆ°æ€ªç‰©è¨Šæ¯',
                        type: 'string',
                        maxLength: 20,
                        category: 'éŠæˆ²å…§ UI'
                    }
                },
                styles: {
                    final: {
                        scoreColor: {
                            label: 'æœ€çµ‚åˆ†æ•¸æ–‡å­—é¡è‰²',
                            type: 'color'
                        }
                    },
                    challengeSuccess: {
                        titleColor: {
                            label: 'æŒ‘æˆ°æˆåŠŸæ¨™é¡Œé¡è‰²',
                            type: 'color'
                        },
                        subtitleColor: {
                            label: 'æŒ‘æˆ°æˆåŠŸå‰¯æ¨™é¡Œé¡è‰²',
                            type: 'color'
                        }
                    },
                    challengeFailed: {
                        titleColor: {
                            label: 'æŒ‘æˆ°å¤±æ•—æ¨™é¡Œé¡è‰²',
                            type: 'color'
                        },
                        subtitleColor: {
                            label: 'æŒ‘æˆ°å¤±æ•—å‰¯æ¨™é¡Œé¡è‰²',
                            type: 'color'
                        }
                    },
                    // åˆ†æ•¸ç³»çµ±
                    score: {
                        color: {
                            label: 'åˆ†æ•¸æ–‡å­—é¡è‰²',
                            type: 'color'
                        }
                    },
                    buttons: {
                        primaryColor: { label: 'ä¸»è¦æŒ‰éˆ•èƒŒæ™¯', type: 'color' },
                        primaryTextColor: { label: 'ä¸»è¦æŒ‰éˆ•æ–‡å­—', type: 'color' },
                        secondaryColor: { label: 'æ¬¡è¦æŒ‰éˆ•èƒŒæ™¯', type: 'color' },
                        secondaryTextColor: { label: 'æ¬¡è¦æŒ‰éˆ•æ–‡å­—', type: 'color' }
                    },
                    overlay: {
                        backgroundColor: {
                            label: 'é®ç½©å±¤èƒŒæ™¯é¡è‰²',
                            type: 'color',
                            category: 'é®ç½©å±¤æ¨£å¼'
                        }
                    },
                    floatingText: {
                        happyColor: {
                            label: 'æŽ¥åˆ°ç¦®ç‰©æ–‡å­—',
                            type: 'color',
                            category: 'æµ®å‹•æ–‡å­—'
                        },
                        ouchColor: {
                            label: 'æŽ¥åˆ°æ€ªç‰©æ–‡å­—',
                            type: 'color',
                            category: 'æµ®å‹•æ–‡å­—'
                        },
                        duration: {
                            label: 'æµ®å‹•æ–‡å­—æŒçºŒæ™‚é–“',
                            type: 'range',
                            min: 200,
                            max: 1000,
                            step: 50,
                            unit: 'ms',
                            category: 'æµ®å‹•æ–‡å­—'
                        }
                    }
                },

                visuals: {
                    cartSrc: { label: 'æŽ¥ç¦®ç‰©ç±ƒå­åœ–ç‰‡', type: 'image' },
                    goodItemSources: {
                        label: 'åŠ åˆ†ç‰©å“',
                        type: 'image',
                        multiple: true,
                        minItems: 1,
                        maxItems: 10
                    },
                    badItemSources: {
                        label: 'æ‰£è¡€ç‰©å“',
                        type: 'image',
                        multiple: true,
                        minItems: 1,
                        maxItems: 5
                    },
                    livesImgSrc: { label: 'ç”Ÿå‘½åœ–æ¡ˆ', type: 'image' }
                },

                gameplay: {
                    soundEnabled: {
                        label: 'å•Ÿç”¨éŸ³æ•ˆ',
                        type: 'boolean',
                        category: 'åŠŸèƒ½é–‹é—œ',
                        hidden: true
                    },
                    difficulty: {
                        itemSpawnChance: {
                            label: 'ç‰©å“ç”Ÿæˆæ©ŸçŽ‡',
                            type: 'range',
                            min: 0.005,
                            max: 0.05,
                            step: 0.005,
                            category: 'éŠæˆ²é›£åº¦',
                            hidden: true
                        },
                        badItemChanceIncrement: {
                            label: 'æ‰£è¡€ç‰©å“æ©ŸçŽ‡å¢žé‡',
                            type: 'range',
                            min: 0.01,
                            max: 0.1,
                            step: 0.01,
                            category: 'éŠæˆ²é›£åº¦',
                            hidden: true
                        },
                        maxBadItemChance: {
                            label: 'æ‰£è¡€ç‰©å“æœ€å¤§æ©ŸçŽ‡',
                            type: 'range',
                            min: 0.1,
                            max: 0.8,
                            step: 0.1,
                            category: 'éŠæˆ²é›£åº¦',
                            hidden: true
                        },
                        maxItemSpeed: {
                            label: 'ç‰©å“æœ€å¤§æŽ‰è½é€Ÿåº¦',
                            type: 'range',
                            min: 3,
                            max: 10,
                            step: 0.5,
                            unit: 'px/frame',
                            category: 'éŠæˆ²é›£åº¦',
                            hidden: true
                        },
                        difficultyScoreInterval: {
                            label: 'åˆ†æ•¸é–“éš”å¢žåŠ é›£åº¦',
                            type: 'range',
                            min: 10,
                            max: 100,
                            step: 5,
                            category: 'éŠæˆ²é›£åº¦',
                            hidden: true
                        }
                    },
                    layout: {
                        cartWidth: {
                            label: 'è³¼ç‰©è»Šå¯¬åº¦',
                            type: 'range',
                            min: 60,
                            max: 150,
                            step: 10,
                            unit: 'px',
                            category: 'ç‰©ä»¶å°ºå¯¸',
                            hidden: true
                        },
                        cartHeight: {
                            label: 'è³¼ç‰©è»Šé«˜åº¦',
                            type: 'range',
                            min: 60,
                            max: 150,
                            step: 10,
                            unit: 'px',
                            category: 'ç‰©ä»¶å°ºå¯¸',
                            hidden: true
                        },
                        minItemSize: {
                            label: 'æŽ‰è½ç‰©æœ€å°å°ºå¯¸',
                            type: 'range',
                            min: 20,
                            max: 60,
                            step: 5,
                            unit: 'px',
                            category: 'ç‰©ä»¶å°ºå¯¸',
                            hidden: true
                        },
                        maxItemSize: {
                            label: 'æŽ‰è½ç‰©æœ€å¤§å°ºå¯¸',
                            type: 'range',
                            min: 40,
                            max: 100,
                            step: 5,
                            unit: 'px',
                            category: 'ç‰©ä»¶å°ºå¯¸',
                            hidden: true
                        },
                        cartBottomOffset: {
                            label: 'è³¼ç‰©è»Šè·é›¢åº•éƒ¨è·é›¢',
                            type: 'range',
                            min: 80,
                            max: 200,
                            step: 10,
                            unit: 'px',
                            category: 'éŠæˆ²è¨­å®š',
                            hidden: true
                        }
                    },
                    minimumScoreToLog: {
                        label: 'éŽé—œåˆ†æ•¸',
                        type: 'number',
                        min: 0,
                        max: 100,
                        step: 1,
                        category: 'åˆ†æ•¸é–€æª»'
                    }
                },

                ui: {
                    hidden: true,
                    lives: {
                        initialLives: {
                            label: 'åˆå§‹ç”Ÿå‘½å€¼',
                            type: 'range',
                            min: 1,
                            max: 10,
                            step: 1,
                            category: 'ç”Ÿå‘½å€¼ç³»çµ±',
                            hidden: true
                        },
                        iconSize: {
                            label: 'ç”Ÿå‘½åœ–æ¡ˆå°ºå¯¸',
                            type: 'range',
                            min: 20,
                            max: 60,
                            step: 5,
                            unit: 'px',
                            category: 'ç”Ÿå‘½å€¼ç³»çµ±',
                            hidden: true
                        },
                        color: {
                            label: 'ç”Ÿå‘½å€¼é¡è‰²',
                            type: 'color',
                            category: 'ç”Ÿå‘½å€¼ç³»çµ±',
                            hidden: true
                        }
                    },
                    score: {
                        fontSize: {
                            label: 'åˆ†æ•¸å­—é«”å¤§å°',
                            type: 'string',
                            category: 'åˆ†æ•¸ç³»çµ±',
                            hidden: true
                        }
                    }
                },

                animations: {
                    hidden: true,
                    hitEffect: {
                        duration: {
                            label: 'å‘½ä¸­æ•ˆæžœæŒçºŒæ™‚é–“',
                            type: 'range',
                            min: 100,
                            max: 500,
                            step: 50,
                            unit: 'ms',
                            category: 'å‘½ä¸­æ•ˆæžœ'
                        },
                        color: {
                            label: 'å‘½ä¸­æ•ˆæžœé¡è‰²',
                            type: 'color',
                            category: 'å‘½ä¸­æ•ˆæžœ'
                        }
                    }
                },

                audio: {
                    hidden: true,
                    start: {
                        note: {
                            label: 'é–‹å§‹éŸ³ç¬¦ (é è¨­)',
                            type: 'string',
                            category: 'éŸ³æ•ˆè¨­å®š (Tone.js)',
                            hidden: true
                        },
                        type: {
                            label: 'æ³¢å½¢é¡žåž‹ (é è¨­)',
                            type: 'select',
                            options: ['triangle', 'sine', 'square', 'sawtooth'],
                            category: 'éŸ³æ•ˆè¨­å®š (Tone.js)',
                            hidden: true
                        },
                        url: {
                            label: 'é–‹å§‹éŸ³æ•ˆæª”æ¡ˆ (é¸å¡«ï¼Œä¸Šå‚³å¾Œè¦†è“‹é è¨­)',
                            type: 'file',
                            category: 'éŸ³æ•ˆè¨­å®š (éŸ³æª”ä¸Šå‚³)',
                            accept: 'audio/*',
                            maxSizeMB: 2,
                            dependsOn: { field: 'gameplay.soundEnabled', value: true },
                            hidden: true
                        },
                        volume: {
                            label: 'éŸ³é‡',
                            type: 'range',
                            min: 0,
                            max: 1,
                            step: 0.1,
                            category: 'éŸ³æ•ˆè¨­å®š',
                            hidden: true
                        }
                    },
                    catchItem: {
                        note: {
                            label: 'æŽ¥ä½ç‰©å“éŸ³ç¬¦ (é è¨­)',
                            type: 'string',
                            category: 'éŸ³æ•ˆè¨­å®š (Tone.js)',
                            hidden: true
                        },
                        type: {
                            label: 'æ³¢å½¢é¡žåž‹ (é è¨­)',
                            type: 'select',
                            options: ['triangle', 'sine', 'square', 'sawtooth'],
                            category: 'éŸ³æ•ˆè¨­å®š (Tone.js)',
                            hidden: true
                        },
                        url: {
                            label: 'æŽ¥ä½åŠ åˆ†ç‰©å“éŸ³æ•ˆæª”æ¡ˆ (é¸å¡«)',
                            type: 'file',
                            category: 'éŸ³æ•ˆè¨­å®š (éŸ³æª”ä¸Šå‚³)',
                            accept: 'audio/*',
                            maxSizeMB: 2,
                            dependsOn: { field: 'gameplay.soundEnabled', value: true },
                            hidden: true
                        },
                        volume: {
                            label: 'éŸ³é‡',
                            type: 'range',
                            min: 0,
                            max: 1,
                            step: 0.1,
                            category: 'éŸ³æ•ˆè¨­å®š',
                            hidden: true
                        }
                    },
                    catchGrinch: {
                        note: {
                            label: 'æŽ¥ä½æ‰£è¡€ç‰©å“éŸ³ç¬¦ (é è¨­)',
                            type: 'string',
                            category: 'éŸ³æ•ˆè¨­å®š (Tone.js)',
                            hidden: true
                        },
                        type: {
                            label: 'æ³¢å½¢é¡žåž‹ (é è¨­)',
                            type: 'select',
                            options: ['triangle', 'sine', 'square', 'sawtooth'],
                            category: 'éŸ³æ•ˆè¨­å®š (Tone.js)',
                            hidden: true
                        },
                        url: {
                            label: 'æŽ¥ä½æ‰£è¡€ç‰©å“éŸ³æ•ˆæª”æ¡ˆ (é¸å¡«)',
                            type: 'file',
                            category: 'éŸ³æ•ˆè¨­å®š (éŸ³æª”ä¸Šå‚³)',
                            accept: 'audio/*',
                            maxSizeMB: 2,
                            dependsOn: { field: 'gameplay.soundEnabled', value: true }
                        },
                        volume: {
                            label: 'éŸ³é‡',
                            type: 'range',
                            min: 0,
                            max: 1,
                            step: 0.1,
                            category: 'éŸ³æ•ˆè¨­å®š',
                            hidden: true
                        }
                    },
                    gameOver: {
                        note: {
                            label: 'éŠæˆ²çµæŸéŸ³ç¬¦ (é è¨­)',
                            type: 'string',
                            category: 'éŸ³æ•ˆè¨­å®š (Tone.js)',
                            hidden: true
                        },
                        type: {
                            label: 'æ³¢å½¢é¡žåž‹ (é è¨­)',
                            type: 'select',
                            options: ['triangle', 'sine', 'square', 'sawtooth'],
                            category: 'éŸ³æ•ˆè¨­å®š (Tone.js)',
                            hidden: true
                        },
                        url: {
                            label: 'éŠæˆ²çµæŸéŸ³æ•ˆæª”æ¡ˆ (é¸å¡«)',
                            type: 'file',
                            category: 'éŸ³æ•ˆè¨­å®š (éŸ³æª”ä¸Šå‚³)',
                            accept: 'audio/*',
                            maxSizeMB: 2,
                            dependsOn: { field: 'gameplay.soundEnabled', value: true },
                            hidden: true
                        },
                        volume: {
                            label: 'éŸ³é‡',
                            type: 'range',
                            min: 0,
                            max: 1,
                            step: 0.1,
                            category: 'éŸ³æ•ˆè¨­å®š',
                            hidden: true
                        }
                    }
                },

                settings: {
                    hidden: true,
                    useCustomAudio: {
                        label: 'ä½¿ç”¨è‡ªè¨‚éŸ³è¨Šæª”æ¡ˆ',
                        type: 'boolean',
                        category: 'åŠŸèƒ½é–‹é—œ',
                        description: 'å•Ÿç”¨ä»¥ä½¿ç”¨ä¸Šå‚³çš„éŸ³è¨Šæª”æ¡ˆï¼Œåœç”¨ä»¥ä½¿ç”¨ Tone.js åˆæˆéŸ³æ•ˆ',
                        hidden: true
                    }
                }
            };

            // ========================================
            // D. å¹³å°æ•´åˆè¦æ±‚ (Platform Integration)
            // ========================================

            // Expose gameConfig and gameConfigMeta to global scope for platform access
            window.gameConfig = gameConfig;
            window.gameConfigMeta = gameConfigMeta;

            // Track game start time for duration calculation
            let gameStartTime = 0;

            // --- Get Canvas and Context ---
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // --- Screen & Overlay Elements ---
            const startScreen = document.getElementById('startScreen');
            const gameOverScreen = document.getElementById('gameOverScreen');
            const victoryScreen = document.getElementById('victoryScreen');
            const startButton = document.getElementById('startButton');
            const restartButtonGO = document.getElementById('restartButtonGO');
            const restartButtonWin = document.getElementById('restartButtonWin');
            const logScoreButton = document.getElementById('logScoreButton');
            const logScoreButtonWin = document.getElementById('logScoreButtonWin');
            const loadingMessage = document.getElementById('loadingMessage');
            const finalScoreGO = document.getElementById('finalScoreGO');

            // --- Tone.js Sound Synths (é è¨­éŸ³æ•ˆ) ---
            const catchSynth = new Tone.Synth().toDestination();
            const gameSynth = new Tone.Synth().toDestination();
            const grinchSynth = new Tone.Synth().toDestination();

            // --- Audio Objects (ä½¿ç”¨è€…ä¸Šå‚³çš„éŸ³æª”) ---
            let audioObjects = {
                start: null,
                catchItem: null,
                catchGrinch: null,
                gameOver: null
            };

            // --- Game State Variables ---
            let score = 0;
            let lives = gameConfig.ui.lives.initialLives;
            let gameStarted = false;
            let gameOver = false;
            let gameWon = false;

            // --- Difficulty Variables ---
            let currentBadItemChance = 0;
            let lastDifficultyIncreaseScore = 0;

            // --- Visual Effect State ---
            let hitEffectEnd = 0; // Timestamp when the red flash effect ends
            let floatingMessage = null; // { text: string, color: string, end: number, x: number, y: number }

            // --- Mobile Scaling ---
            const mobileScaleFactor = 0.7;
            const mobileBreakpoint = 768; // æ‰‹æ©Ÿè£ç½®æ–·é»žï¼ˆpxï¼‰

            /**
             * åµæ¸¬æ˜¯å¦ç‚ºæ‰‹æ©Ÿè£ç½®
             * @returns {boolean} æ˜¯å¦ç‚ºæ‰‹æ©Ÿè£ç½®
             */
            const isMobileDevice = () => window.innerWidth <= mobileBreakpoint;

            /**
             * å–å¾—ç¸®æ”¾ä¿‚æ•¸
             * @returns {number} ç¸®æ”¾ä¿‚æ•¸ï¼ˆæ‰‹æ©Ÿç‚º 0.6ï¼Œæ¡Œé¢ç‚º 1ï¼‰
             */
            const getScaleFactor = () => (isMobileDevice() ? mobileScaleFactor : 1);

            /**
             * å–å¾—ç¸®æ”¾å¾Œçš„è³¼ç‰©è»Šå°ºå¯¸
             * @returns {{ width: number, height: number }} ç¸®æ”¾å¾Œçš„è³¼ç‰©è»Šå¯¬é«˜
             */
            const getScaledCartSize = () => {
                const scale = getScaleFactor();
                return {
                    width: gameConfig.gameplay.layout.cartWidth * scale,
                    height: gameConfig.gameplay.layout.cartHeight * scale
                };
            };

            /**
             * å–å¾—ç¸®æ”¾å¾Œçš„æŽ‰è½ç‰©å°ºå¯¸ç¯„åœ
             * @returns {{ min: number, max: number }} ç¸®æ”¾å¾Œçš„æœ€å°å’Œæœ€å¤§å°ºå¯¸
             */
            const getScaledItemSize = () => {
                const scale = getScaleFactor();
                return {
                    min: gameConfig.gameplay.layout.minItemSize * scale,
                    max: gameConfig.gameplay.layout.maxItemSize * scale
                };
            };

            // --- Game Objects ---
            const initialCartSize = getScaledCartSize();
            let cart = {
                width: initialCartSize.width,
                height: initialCartSize.height,
                x: window.innerWidth / 2 - initialCartSize.width / 2,
                y: window.innerHeight - gameConfig.gameplay.layout.cartBottomOffset,
                hitbox: {
                    width: gameConfig.gameplay.layout.cartHitbox.width * getScaleFactor(),
                    height: gameConfig.gameplay.layout.cartHitbox.height * getScaleFactor(),
                    offsetY: gameConfig.gameplay.layout.cartHitbox.offsetY * getScaleFactor()
                }
            };
            let items = [];

            // --- Image Loading ---
            let cartImg = new Image();
            let goodItemImages = [];
            let badItemImages = [];
            let livesImg = new Image();
            let imagesLoaded = 0;
            const totalImages =
                gameConfig.visuals.goodItemSources.length +
                gameConfig.visuals.badItemSources.length +
                1 +
                1;

            // Function to preload all game images
            function preloadImages() {
                const onImageLoad = () => {
                    imagesLoaded++;
                    const percentage = Math.round((imagesLoaded / totalImages) * 100);
                    loadingMessage.textContent = gameConfig.text.loadingComplete(percentage);
                    if (imagesLoaded === totalImages) {
                        loadingMessage.style.display = 'none';
                        startButton.style.display = 'block';
                    }
                };

                const onImageError = e => {
                    console.warn(`Could not load image: ${e.target.src}. Using placeholder.`);
                    const isCart = e.target.src === gameConfig.visuals.cartSrc;
                    const isLives = e.target.src === gameConfig.visuals.livesImgSrc;
                    const width = isCart
                        ? gameConfig.gameplay.layout.cartWidth
                        : isLives
                        ? gameConfig.ui.lives.iconSize
                        : gameConfig.gameplay.layout.minItemSize;
                    const height = isCart
                        ? gameConfig.gameplay.layout.cartHeight
                        : isLives
                        ? gameConfig.ui.lives.iconSize
                        : gameConfig.gameplay.layout.minItemSize;
                    const text = isCart ? 'Cart' : isLives ? 'Life' : 'Item';
                    e.target.src = gameConfig.visuals.placeholderUrl(width, height, text);
                    onImageLoad();
                };

                cartImg.src = gameConfig.visuals.cartSrc;
                cartImg.onload = onImageLoad;
                cartImg.onerror = onImageError;

                // è¼‰å…¥åŠ åˆ†ç‰©å“åœ–ç‰‡
                gameConfig.visuals.goodItemSources.forEach(src => {
                    const img = new Image();
                    img.src = src;
                    img.onload = onImageLoad;
                    img.onerror = onImageError;
                    goodItemImages.push(img);
                });

                // è¼‰å…¥æ‰£è¡€ç‰©å“åœ–ç‰‡
                gameConfig.visuals.badItemSources.forEach(src => {
                    const img = new Image();
                    img.src = src;
                    img.onload = onImageLoad;
                    img.onerror = onImageError;
                    badItemImages.push(img);
                });

                livesImg.src = gameConfig.visuals.livesImgSrc;
                livesImg.onload = onImageLoad;
                livesImg.onerror = onImageError;
            }

            // --- Canvas and Sizing ---
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                cart.y = canvas.height - gameConfig.gameplay.layout.cartBottomOffset;

                // æ ¹æ“šè£ç½®é¡žåž‹æ›´æ–°è³¼ç‰©è»Šå°ºå¯¸
                const scaledCartSize = getScaledCartSize();
                const scale = getScaleFactor();
                cart.width = scaledCartSize.width;
                cart.height = scaledCartSize.height;
                cart.hitbox = {
                    width: gameConfig.gameplay.layout.cartHitbox.width * scale,
                    height: gameConfig.gameplay.layout.cartHitbox.height * scale,
                    offsetY: gameConfig.gameplay.layout.cartHitbox.offsetY * scale
                };

                // ç¢ºä¿è³¼ç‰©è»Šä¸è¶…å‡ºç•«å¸ƒé‚Šç•Œ
                if (cart.x + cart.width > canvas.width) {
                    cart.x = canvas.width - cart.width;
                }
            }

            function setupText() {
                document.title = gameConfig.text.documentTitle;
                loadingMessage.textContent = gameConfig.text.loading;

                document.getElementById('startTitle').textContent = gameConfig.text.startTitle;
                document.getElementById('startSubtitle').textContent =
                    gameConfig.text.startSubtitle;
                startButton.textContent = gameConfig.text.startButton;

                document.getElementById('gameOverTitle').textContent =
                    gameConfig.text.challengeSuccessTitle;
                document.getElementById('gameOverTitle').style.color =
                    gameConfig.styles.challengeSuccess.titleColor;
                document.getElementById('gameOverSubtitle').textContent =
                    gameConfig.text.challengeSuccessSubtitle;
                document.getElementById('gameOverSubtitle').style.color =
                    gameConfig.styles.challengeSuccess.subtitleColor;
                restartButtonGO.textContent = gameConfig.text.restartButton;
                logScoreButton.textContent = gameConfig.text.logScoreButton;

                restartButtonWin.textContent = gameConfig.text.restartButton;
                logScoreButtonWin.textContent = gameConfig.text.logScoreButton;
            }

            // Helper function to adjust color brightness
            function adjustColorBrightness(color, percent) {
                const num = parseInt(color.replace('#', ''), 16);
                const r = Math.min(255, Math.max(0, (num >> 16) + percent));
                const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00ff) + percent));
                const b = Math.min(255, Math.max(0, (num & 0x0000ff) + percent));
                return '#' + (0x1000000 + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }

            function setupButtonStyles() {
                const primaryButtons = [startButton, restartButtonGO, restartButtonWin];
                const secondaryButtons = [logScoreButton, logScoreButtonWin];
                const {
                    primaryColor,
                    primaryTextColor,
                    secondaryColor,
                    secondaryTextColor
                } = gameConfig.styles.buttons;

                // Auto-calculate hover and active colors
                const primaryHoverColor = adjustColorBrightness(primaryColor, 20);
                const primaryActiveColor = adjustColorBrightness(primaryColor, -20);
                const secondaryHoverColor = adjustColorBrightness(secondaryColor, 20);
                const secondaryActiveColor = adjustColorBrightness(secondaryColor, -20);

                // Setup primary button styles
                primaryButtons.forEach(button => {
                    button.style.background = primaryColor;
                    button.style.color = primaryTextColor;

                    button.addEventListener('mouseenter', () => {
                        button.style.background = primaryHoverColor;
                    });
                    button.addEventListener('mouseleave', () => {
                        button.style.background = primaryColor;
                    });
                    button.addEventListener('mousedown', () => {
                        button.style.background = primaryActiveColor;
                    });
                    button.addEventListener('mouseup', () => {
                        button.style.background = primaryHoverColor;
                    });
                });

                // Setup secondary button styles
                secondaryButtons.forEach(button => {
                    button.style.background = secondaryColor;
                    button.style.color = secondaryTextColor;

                    button.addEventListener('mouseenter', () => {
                        button.style.background = secondaryHoverColor;
                    });
                    button.addEventListener('mouseleave', () => {
                        button.style.background = secondaryColor;
                    });
                    button.addEventListener('mousedown', () => {
                        button.style.background = secondaryActiveColor;
                    });
                    button.addEventListener('mouseup', () => {
                        button.style.background = secondaryHoverColor;
                    });
                });
            }

            function setupOverlayStyles() {
                const overlays = [startScreen, gameOverScreen, victoryScreen];
                // Grab the full string directly
                const { backgroundColor } = gameConfig.styles.overlay;

                overlays.forEach(overlay => {
                    // Apply it directly
                    overlay.style.background = backgroundColor;
                });
            }

            // --- Game Setup ---
            function init() {
                setupText();
                setupButtonStyles();
                setupOverlayStyles();
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                window.addEventListener('mousemove', e => {
                    moveCart(e.clientX);
                });
                window.addEventListener(
                    'touchmove',
                    e => {
                        e.preventDefault();
                        moveCart(e.touches[0].clientX);
                    },
                    { passive: false }
                );

                startButton.addEventListener('click', startGame);
                restartButtonGO.addEventListener('click', startGame);
                restartButtonWin.addEventListener('click', startGame);
                logScoreButton.addEventListener('click', logScoreHandler);
                logScoreButtonWin.addEventListener('click', logScoreHandler);

                preloadImages();
                setupAudio();
            }

            // åˆå§‹åŒ–éŸ³æ•ˆï¼ˆæ··åˆæ¨¡å¼ï¼šå„ªå…ˆä½¿ç”¨ç”¨æˆ¶ä¸Šå‚³çš„éŸ³æª”ï¼Œæ²’æœ‰å‰‡ä½¿ç”¨ Tone.jsï¼‰
            function setupAudio() {
                // è¨­ç½® Tone.js synths
                catchSynth.oscillator.type = gameConfig.audio.catchItem.type;
                gameSynth.oscillator.type = gameConfig.audio.start.type;
                grinchSynth.oscillator.type = gameConfig.audio.catchGrinch.type;

                // è¼‰å…¥ç”¨æˆ¶ä¸Šå‚³çš„éŸ³æª”ï¼ˆå¦‚æžœæœ‰ï¼‰
                if (gameConfig.audio.start.url) {
                    audioObjects.start = new Audio(gameConfig.audio.start.url);
                    audioObjects.start.volume = gameConfig.audio.start.volume;
                }
                if (gameConfig.audio.catchItem.url) {
                    audioObjects.catchItem = new Audio(gameConfig.audio.catchItem.url);
                    audioObjects.catchItem.volume = gameConfig.audio.catchItem.volume;
                }
                if (gameConfig.audio.catchGrinch.url) {
                    audioObjects.catchGrinch = new Audio(gameConfig.audio.catchGrinch.url);
                    audioObjects.catchGrinch.volume = gameConfig.audio.catchGrinch.volume;
                }
                if (gameConfig.audio.gameOver.url) {
                    audioObjects.gameOver = new Audio(gameConfig.audio.gameOver.url);
                    audioObjects.gameOver.volume = gameConfig.audio.gameOver.volume;
                }
            }

            // Play sound (hybrid mode: based on useCustomAudio setting, use either uploaded files or Tone.js)
            function playSound(soundName) {
                if (!gameConfig.gameplay.soundEnabled) return;

                const audio = audioObjects[soundName];
                const config = gameConfig.audio[soundName];

                // Check useCustomAudio setting to determine audio source
                if (gameConfig.gameplay.soundEnabled && audio && audio.src) {
                    // Use uploaded custom audio file
                    audio.currentTime = 0;
                    audio.play().catch(e => {
                        console.warn(`Failed to play ${soundName} sound:`, e);
                    });
                } else {
                    // Use Tone.js synthesized sound
                    Tone.start().then(() => {
                        if (!config) return;

                        if (soundName === 'start') {
                            gameSynth.oscillator.type = config.type;
                            gameSynth.triggerAttackRelease(
                                config.note,
                                config.duration,
                                Tone.now()
                            );
                        } else if (soundName === 'catchItem') {
                            catchSynth.triggerAttackRelease(
                                config.note,
                                config.duration,
                                Tone.now()
                            );
                        } else if (soundName === 'catchGrinch') {
                            grinchSynth.triggerAttackRelease(
                                config.note,
                                config.duration,
                                Tone.now()
                            );
                        } else if (soundName === 'gameOver') {
                            gameSynth.oscillator.type = config.type;
                            gameSynth.triggerAttackRelease(
                                config.note,
                                config.duration,
                                Tone.now()
                            );
                        }
                    });
                }
            }

            function logScoreHandler() {
                const gameDuration = Date.now() - gameStartTime;
                console.log(`[SUBMIT SCORE] Score: ${score}, Duration: ${gameDuration}ms`);

                logScoreButton.disabled = true;
                logScoreButton.textContent = gameConfig.text.scoreLogged;
                logScoreButtonWin.disabled = true;
                logScoreButtonWin.textContent = gameConfig.text.scoreLogged;

                if (window.feverGame && typeof window.feverGame.onComplete === 'function') {
                    try {
                        window.feverGame.onComplete({
                            score: score,
                            duration: gameDuration,
                            startTime: gameStartTime
                        });
                        console.log(
                            `[FEVER GAME] Score logged: score=${score}, duration=${gameDuration}ms`
                        );
                    } catch (e) {
                        console.error('[FEVER GAME] Failed to log score:', e);
                        logScoreButton.disabled = false;
                        logScoreButton.textContent = gameConfig.text.logScoreButton;
                        logScoreButtonWin.disabled = false;
                        logScoreButtonWin.textContent = gameConfig.text.logScoreButton;
                    }
                } else {
                    console.log('[FEVER GAME] Platform API not available');
                }
            }

            function startGame() {
                score = 0;
                lives = gameConfig.ui.lives.initialLives;
                gameStarted = true;
                gameOver = false;
                gameWon = false;
                items = [];
                gameStartTime = Date.now();

                // è¨ˆç®—åˆå§‹æ‰£è¡€ç‰©å“æ©ŸçŽ‡
                const totalItemTypes = goodItemImages.length + badItemImages.length;
                currentBadItemChance =
                    totalItemTypes > 0 ? badItemImages.length / totalItemTypes : 0.1;
                lastDifficultyIncreaseScore = 0;

                // é‡è¨­è¦–è¦ºæ•ˆæžœç‹€æ…‹
                hitEffectEnd = 0;
                floatingMessage = null;

                startScreen.style.display = 'none';
                gameOverScreen.style.display = 'none';
                victoryScreen.style.display = 'none';

                logScoreButton.disabled = false;
                logScoreButton.textContent = gameConfig.text.logScoreButton;
                logScoreButtonWin.disabled = false;
                logScoreButtonWin.textContent = gameConfig.text.logScoreButton;

                // æ’­æ”¾é–‹å§‹éŸ³æ•ˆ
                playSound('start');

                gameLoop();
            }

            function moveCart(x) {
                if (!gameStarted) return;
                cart.x = x - cart.width / 2;

                if (cart.x < 0) cart.x = 0;
                if (cart.x + cart.width > canvas.width) cart.x = canvas.width - cart.width;
            }

            function createItem() {
                let randomImg;
                let isBadItem = false;

                // æ ¹æ“šæ©ŸçŽ‡æ±ºå®šæ˜¯åŠ åˆ†ç‰©å“é‚„æ˜¯æ‰£è¡€ç‰©å“
                if (Math.random() < currentBadItemChance && badItemImages.length > 0) {
                    // é¸æ“‡æ‰£è¡€ç‰©å“
                    const randomIndex = Math.floor(Math.random() * badItemImages.length);
                    randomImg = badItemImages[randomIndex];
                    isBadItem = true;
                } else if (goodItemImages.length > 0) {
                    // é¸æ“‡åŠ åˆ†ç‰©å“
                    const randomIndex = Math.floor(Math.random() * goodItemImages.length);
                    randomImg = goodItemImages[randomIndex];
                    isBadItem = false;
                } else {
                    // å¦‚æžœæ²’æœ‰åŠ åˆ†ç‰©å“ï¼Œå‰‡é¸æ“‡æ‰£è¡€ç‰©å“
                    const randomIndex = Math.floor(Math.random() * badItemImages.length);
                    randomImg = badItemImages[randomIndex];
                    isBadItem = true;
                }

                // æ ¹æ“šè£ç½®é¡žåž‹å–å¾—ç¸®æ”¾å¾Œçš„æŽ‰è½ç‰©å°ºå¯¸
                const scaledSize = getScaledItemSize();
                const itemSize = Math.random() * (scaledSize.max - scaledSize.min) + scaledSize.min;

                items.push({
                    x: Math.random() * (canvas.width - itemSize),
                    y: -itemSize,
                    width: itemSize,
                    height: itemSize,
                    speed:
                        Math.random() *
                            (gameConfig.gameplay.difficulty.maxItemSpeed -
                                gameConfig.gameplay.difficulty.minItemSpeed) +
                        gameConfig.gameplay.difficulty.minItemSpeed,
                    img: randomImg,
                    isBadItem: isBadItem
                });
            }

            function update() {
                if (!gameStarted || gameOver || gameWon) return;

                if (
                    score >=
                    lastDifficultyIncreaseScore +
                        gameConfig.gameplay.difficulty.difficultyScoreInterval
                ) {
                    lastDifficultyIncreaseScore = score;
                    const increment = gameConfig.gameplay.difficulty.badItemChanceIncrement;
                    const maxChance = gameConfig.gameplay.difficulty.maxBadItemChance;

                    if (currentBadItemChance < maxChance) {
                        currentBadItemChance += increment;
                        if (currentBadItemChance > maxChance) {
                            currentBadItemChance = maxChance;
                        }
                        console.log(
                            `[Difficulty] Bad item chance increased to: ${currentBadItemChance.toFixed(
                                3
                            )} at score ${score}`
                        );
                    }
                }

                if (Math.random() < gameConfig.gameplay.difficulty.itemSpawnChance) {
                    createItem();
                }

                for (let i = items.length - 1; i >= 0; i--) {
                    const item = items[i];
                    item.y += item.speed;

                    const cartHitboxX = cart.x + (cart.width - cart.hitbox.width) / 2;
                    const cartHitboxY = cart.y + cart.hitbox.offsetY;

                    if (
                        item.x < cartHitboxX + cart.hitbox.width &&
                        item.x + item.width > cartHitboxX &&
                        item.y < cartHitboxY + cart.hitbox.height &&
                        item.y + item.height > cartHitboxY
                    ) {
                        if (item.isBadItem) {
                            // æ‰£è¡€ç‰©å“
                            lives--;

                            const currentTime = Date.now();
                            const floatingDuration = gameConfig.styles.floatingText.duration;

                            // è§¸ç™¼ç´…é–ƒæ•ˆæžœ
                            hitEffectEnd = currentTime + gameConfig.animations.hitEffect.duration;

                            // é¡¯ç¤º "å“Žå–²ï¼" æµ®å‹•æ–‡å­—
                            floatingMessage = {
                                text: gameConfig.text.catchOuch,
                                color: gameConfig.styles.floatingText.ouchColor,
                                end: currentTime + floatingDuration,
                                x: item.x + item.width / 2,
                                y: item.y
                            };

                            // æ’­æ”¾æ‰£è¡€éŸ³æ•ˆ
                            playSound('catchGrinch');

                            if (lives <= 0) {
                                // é‡è¨­è¦–è¦ºæ•ˆæžœç‹€æ…‹
                                hitEffectEnd = 0;
                                gameOver = true;
                                gameStarted = false;
                                finalScoreGO.textContent = gameConfig.text.finalScorePrefix + score;
                                finalScoreGO.style.color = gameConfig.styles.final.scoreColor;
                                // æª¢æŸ¥æ˜¯å¦é”åˆ°æœ€ä½Žç™»éŒ„åˆ†æ•¸
                                const minScore = gameConfig.gameplay.minimumScoreToLog;
                                const gameOverTitle = document.getElementById('gameOverTitle');
                                const gameOverSubtitle = document.getElementById(
                                    'gameOverSubtitle'
                                );

                                if (score >= minScore) {
                                    // é”åˆ°æœ€ä½Žåˆ†æ•¸ï¼Œé¡¯ç¤ºæŒ‘æˆ°æˆåŠŸç•«é¢
                                    gameOverTitle.textContent =
                                        gameConfig.text.challengeSuccessTitle;
                                    gameOverSubtitle.textContent =
                                        gameConfig.text.challengeSuccessSubtitle;
                                    gameOverSubtitle.style.color =
                                        gameConfig.styles.challengeSuccess.subtitleColor;
                                    logScoreButton.style.display = 'inline-block';
                                } else {
                                    // æœªé”åˆ°æœ€ä½Žåˆ†æ•¸ï¼Œé¡¯ç¤ºæŒ‘æˆ°å¤±æ•—ç•«é¢
                                    gameOverTitle.textContent =
                                        gameConfig.text.challengeFailedTitle;
                                    gameOverSubtitle.textContent = gameConfig.text.challengeFailedMessage.replace(
                                        '{minScore}',
                                        minScore
                                    );
                                    gameOverSubtitle.style.color =
                                        gameConfig.styles.challengeFailed.subtitleColor;
                                    logScoreButton.style.display = 'none';
                                }

                                gameOverScreen.style.display = 'flex';

                                // æ’­æ”¾éŠæˆ²çµæŸéŸ³æ•ˆ
                                playSound('gameOver');
                            }
                        } else {
                            // åŠ åˆ†ç‰©å“
                            score++;

                            const currentTime = Date.now();
                            const floatingDuration = gameConfig.styles.floatingText.duration;

                            // é¡¯ç¤º "é–‹å¿ƒï¼" æµ®å‹•æ–‡å­—
                            floatingMessage = {
                                text: gameConfig.text.catchHappy,
                                color: gameConfig.styles.floatingText.happyColor,
                                end: currentTime + floatingDuration,
                                x: item.x + item.width / 2,
                                y: item.y
                            };

                            // æ’­æ”¾æŽ¥ä½ç‰©å“éŸ³æ•ˆ
                            playSound('catchItem');
                        }

                        items.splice(i, 1);
                    } else if (item.y > canvas.height) {
                        items.splice(i, 1);
                    }
                }
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ctx.drawImage(cartImg, cart.x, cart.y, cart.width, cart.height);

                items.forEach(item => {
                    ctx.drawImage(item.img, item.x, item.y, item.width, item.height);
                });

                // Draw red flash effect when hit by bad item
                if (Date.now() < hitEffectEnd) {
                    const remainingTime = hitEffectEnd - Date.now();
                    const opacity =
                        (remainingTime / gameConfig.animations.hitEffect.duration) * 0.8;
                    // Parse hit effect color from config (supports hex, rgb, rgba)
                    const hitColor = gameConfig.animations.hitEffect.color;
                    let r = 255,
                        g = 0,
                        b = 0; // default red
                    if (hitColor.startsWith('#')) {
                        // Hex format: #RGB or #RRGGBB
                        const hex = hitColor.slice(1);
                        if (hex.length === 3) {
                            r = parseInt(hex[0] + hex[0], 16);
                            g = parseInt(hex[1] + hex[1], 16);
                            b = parseInt(hex[2] + hex[2], 16);
                        } else {
                            r = parseInt(hex.slice(0, 2), 16);
                            g = parseInt(hex.slice(2, 4), 16);
                            b = parseInt(hex.slice(4, 6), 16);
                        }
                    } else if (hitColor.startsWith('rgb')) {
                        // RGB/RGBA format: rgb(r,g,b) or rgba(r,g,b,a)
                        const match = hitColor.match(/rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
                        if (match) {
                            r = parseInt(match[1], 10);
                            g = parseInt(match[2], 10);
                            b = parseInt(match[3], 10);
                        }
                    }
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                if (gameStarted) {
                    drawUI();
                    drawFloatingMessage();
                }
            }

            function drawUI() {
                const scale = getScaleFactor();
                
                // æ ¹æ“šç¸®æ”¾ä¿‚æ•¸èª¿æ•´åˆ†æ•¸å­—é«”å¤§å°
                const baseFontSize = parseInt(gameConfig.ui.score.fontSize);
                const scaledFontSize = Math.round(baseFontSize * scale);
                
                ctx.fillStyle = gameConfig.styles.score.color;
                ctx.font = `${gameConfig.ui.score.fontWeight} ${scaledFontSize}px ${gameConfig.styles.fonts.family}`;
                ctx.textAlign = 'left';
                ctx.fillText(
                    gameConfig.text.scorePrefix + score,
                    gameConfig.ui.score.xOffset,
                    gameConfig.ui.score.yOffset
                );

                // æ ¹æ“šç¸®æ”¾ä¿‚æ•¸èª¿æ•´ç”Ÿå‘½åœ–æ¡ˆå°ºå¯¸
                const iconSize = Math.round(gameConfig.ui.lives.iconSize * scale);
                const spacing = iconSize + 5;
                const startX = canvas.width - spacing;
                const y = 15;

                for (let i = 0; i < lives; i++) {
                    const x = canvas.width - spacing * (i + 1);

                    if (livesImg.complete && livesImg.naturalWidth !== 0) {
                        ctx.drawImage(livesImg, x, y, iconSize, iconSize);
                    } else {
                        ctx.fillStyle = gameConfig.ui.lives.color;
                        const fallbackFontSize = Math.round(36 * scale);
                        ctx.font = `${fallbackFontSize}px Arial`;
                        ctx.textAlign = 'right';
                        ctx.fillText('â™¥', x + iconSize, y + iconSize);
                    }
                }
            }

            // Draw floating message (é–‹å¿ƒï¼ or å“Žå–²ï¼)
            function drawFloatingMessage() {
                if (!floatingMessage || Date.now() > floatingMessage.end) {
                    floatingMessage = null;
                    return;
                }

                const timeRemaining = floatingMessage.end - Date.now();
                const duration = gameConfig.styles.floatingText.duration;

                // Fade out effect: opacity goes from 1 to 0
                const opacity = timeRemaining / duration;

                // Slight upward movement effect: move up by 30 pixels over duration
                const initialY = floatingMessage.y;
                const travelDistance = 30;
                const currentY = initialY - travelDistance * (1 - opacity);

                ctx.globalAlpha = opacity;
                ctx.fillStyle = floatingMessage.color;
                ctx.font = gameConfig.styles.floatingText.font;
                ctx.textAlign = 'center';
                ctx.fillText(floatingMessage.text, floatingMessage.x, currentY);
                ctx.globalAlpha = 1.0; // Reset alpha for other drawing
            }

            function gameLoop() {
                if (!gameStarted) return;

                update();
                draw();

                requestAnimationFrame(gameLoop);
            }

            init();
        </script>
    </body>
</html>
